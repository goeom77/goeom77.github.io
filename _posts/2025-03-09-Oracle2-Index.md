---
layout: post
title:  " [Oracle] "
categories: Oracle
author: start-easy
---
* content
{:toc}

## 0. 옵티마이저란?

- **옵티마이저**는 SQL문을 실행할 때 최적의 실행 계획을 선택하는 역할을 하는 핵심 구성요소

- 9g 이하에서는 규칙 기반 옵티마이저로 테이블 풀 스캔보다는 인덱스 스캔을 우선으로 적용

- 10g 이후는 비용 기반 옵티마이저로 통계 정보를 기반으로 최적의 경로 선택

- 옵티마이저 힌트

1. 풀 테이블 스캔 강제

```shell
SELECT /*+ FULL(emp) */ * FROM emp;
```


2. 특정 인덱스 사용 강제

```shell
SELECT /*+ INDEX(emp emp_idx) */ * FROM emp WHERE emp_no = 100;
```

- 옵티마이저 구성

SQL 변환 → 접근 경로 결정 → 조인 방식 결정 → 비용 계산 → 실행 계획 선택 → SQL 실행


## 1. 인덱스 구조

기본적으로 B*Tree 형식을 가지고 있습니다. 따라서 탐색 방법은 루트에서 리프까지 수직적 탐색, 리프에서 원하는 값을 찾는 수평적 탐색으로 나뉩니다.

최말단 리프 블록은 **인덱스 키**컬럼과 **주소정보(row id)**를 갖습니다.
또한 주소 정보(row id)순으로 정렬되어 있기에 필요한 값을 찾을 때 일정 범위만 찾는 **범위 스캔**을 하는 경우도 있습니다.

cf) Left Most Child

브랜치 노드와 각 엔트리는 키 값과 하위 노드를 가리키는 블록 주소를 갖습니다. 하지만 키 값을 가지지 않는 엔트리가 존재합니다.
가장 첫 노드이고, 이를 **lmc**라고 부릅니다.

## 1-1 익덱스 구조와 특징

1. 리프 노드상의 인덱스 레코드와 테이블 레코드 간 1:1관계

2. 리프 노드상의 키값과 테이블 레코드 키 값은 일치

3. 브랜치 노드상의 레코드 개수는 하위 레벨 블록 개수와 일치

4. 브랜치 노드상의 키 값은 하위 노드가 갖는 값의 범위를 의미

---

궁금한 점 : 리프 노드 상의 엔트리 값이 갱신되더라도 브랜치 노드까지 값이 변경되지 않는다. 하지만 키 값은 하위 노드가 갖는 값의 범위를 안다. 어떻게 알 수 있는 것일까?

- 브랜치 노드는 리프 노드의 "최소 값(첫 번째 엔트리 키)"만 저장한다.

- 즉, 브랜치 노드 값은 그 하위 리프 노드에서 가장 작은 값을 대표한다.

- 리프 노드에서 데이터가 변경되더라도, 해당 노드의 최소 값이 유지되면 브랜치 노드는 변하지 않는 것이다.

---

## 1-2 인덱스 탐색

1. 수평적 탐색

- 인덱스 레코드 간 논리적 순서에 따라 좌측 또는 우측으로 스캔하는 것

2. 수직적 탐색

- **수평적 탐색을 위한 시작 지점을 찾는 과정**으로 루트에서 리프로 아래로 스캔

## 1-3 인덱스 탐색 방법

1. 브랜치 블록 스캔

2. 결합 엔덱스 구조

- 인덱스 값을 결합 구조로 가지고 탐색하는 것

- 인덱스 값이 2개가 있다면 **2번째 레코드를 기준으로 먼저 탐색한다.**

## 1-4 row ID 포맷

- 물리적 위치정보를 포함한다.
row id : 데이터 파일 번호 + 블록 번호 + 로우 번호

- 테이블 자체에 저장되는 것이 아니라 인덱스에 저장된다.(경로를 찾는 것이기 때문에) : pseudo(슈도) 컬럼이다.

cf) ㅔ

- 
